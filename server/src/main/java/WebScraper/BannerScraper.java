package WebScraper;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
/**
 * Handles requests to view a list of CS requirements by scraping concentration information from
 * a given Banner html String, returning it as a list of a list of strings.
 */
public class BannerScraper {
  ArrayList<Requirement> requirements;
  String html;
  /**
   * Searches html for a table and converts the table into the appropriate data format.
   * @param html - Banner html data to search concentration information for
   */
  public BannerScraper(String html) {
    this.html = html;
    requirements = new ArrayList<>();
    parseTable();
    validateRequirements();
  }
  /**
   * Parses the first table found in the html file and creates requirements, options to fulfill
   * such requirements, and courses to fulfill such options.
   */
  private void parseTable() {
    Document doc = Jsoup.parse(this.html);
    Elements rows = doc.select("tr");
    String currentHours = null;
    HashSet<Option> options = new HashSet<>();
    int rowNumber = 0;
    String name = "";
    // Iterates over every row in the table
    for (int j = 0; j < rows.size(); j++) {
      Element row = rows.get(j);
      Element hoursCol = row.selectFirst("td.hourscol");
      if (j == 0) name = row.selectFirst("td").text();
      // Checks to see if a new requirement has appeared
      if ((hoursCol != null) && (!hoursCol.text().isEmpty())) {
        String hours = hoursCol.text().trim();
        if (currentHours != null) {
          // Creates new requirement based on values of previous row
          requirements.add(new Requirement(name, options, currentHours, rowNumber));
        }
        options = new HashSet<>();
        currentHours = hours;
        rowNumber = j;
        name = row.selectFirst("td").text();
      }
      // Object of all Java Elements where course codes are listed
      Elements codeCols = row.select("td.codecol div a");
      // Object of all Java Elements in the entire row
      Elements allCols = row.select("td");
      HashSet<Course> courses = new HashSet<>();
      // Gets all text in a singular row of table
      String title = allCols.get(allCols.size() - 1).text();
      // Iterates over all the courses in a row to be added to a new option
      for (int i = 0; i < codeCols.size(); i++) {
        // If last column in row is empty
        if (Arrays.toString(allCols.get(allCols.size() - 1).html().
            split("<br>")).equals("[]")) {
          // Array of column in row
          String[] parts = allCols.get(allCols.size() - 2).html().split("<br>");
          // Sets the title to the detected course name
          if (i == 0) title = parts[0];
          else title = parts[i].substring(56, parts[i].length() - 7);
        }
        // Creates a new course if a course code was present in row
        if (!codeCols.get(i).text().isEmpty()) {
          Course newCourse = new Course(codeCols.get(i).text(), title, j);
          courses.add(newCourse);
        }
      }
      // Creates new option to fulfill requirement if courses has been cleared
      if (!courses.isEmpty()) options.add(new Option(courses));
    }
  }
  /**
   * Analyzes the requirements created by parseTable for irregularities/inconsistencies and fixes
   * the data generated by adding text from rows that did not meet the course format.
   */
  public void validateRequirements() {
    // Iterates over every requirement
    for (int i = 0; i < requirements.size(); i++) {
      Requirement requirement = requirements.get(i);
      boolean valid = true;
      // If a requirement has no options, there were rows the parseTable code missed
      if (requirement.options.isEmpty()) {
        valid = false;
      } else {
        // If a requirement has options with fewer courses than are needed to fulfill it,
        // there were rows the parseTable code missed
        for (Option option : requirement.options) {
          if (Integer.parseInt(requirement.hours) > option.courses.size()) {
            valid = false;
            break;
          }
        }
      }
      // If this requirement missed rows, add missing courses as raw text to the requirement data
      if (!valid) {
        Document doc = Jsoup.parse(html);
        Elements rows = doc.select("tr");
        int currentRequirement = requirement.rowNumber;
        int nextRequirement;
        if (i < requirements.size() - 1) {
          nextRequirement = requirements.get(i + 1).rowNumber;
        } else {
          nextRequirement = rows.size() - 1;
        }
        HashSet<Course> newCourses = new HashSet<>();
        if (requirement.options.isEmpty()) {
          // if the requirement has no options, create one for courses to be added to
          Option newOption = new Option(newCourses);
          requirement.options.add(newOption);
        } else {
          for (Option onlyOption : requirement.options) {
            if (Integer.parseInt(requirement.hours) > onlyOption.courses.size()) {
              // if the requirement has an option with fewer courses than are needed to fulfill it,
              // add to the options list of courses
              newCourses = onlyOption.courses;
              break;
            }
          }
        }
        for (int j = 0; j < rows.size(); j++) {
          if (j > currentRequirement && j < nextRequirement) {
            Element row = rows.get(j);
            HashSet<Integer> usedRows = new HashSet<>();
            for (Option option : requirement.options) {
              for (Course course : option.courses) {
                usedRows.add(course.row);
              }
            }
            if (row.text().split(" ").length > 3 && !usedRows.contains(j)) {
              // add missing courses as "PICK YOUR OWN" Courses
              newCourses.add(new Course("PICK YOUR OWN", row.text(), j));
            }
          }
        }
      }
    }
  }
  /**
   * Returns the requirements created by parseTable and validated by validateRequirements.
   * @return concentration requirements as a List of List of Strings
   */
  public List<List<String>> requirementsToList() {
    List<List<String>> result = new ArrayList<>();
    for (Requirement requirement : requirements) {
      List<String> requirementList = new ArrayList<>();
      requirementList.add(requirement.name);
      requirementList.add(requirement.hours);
      result.add(requirementList);
      for (Option option : requirement.options) {
        List<String> optionsList = new ArrayList<>();
        optionsList.add("New Option");
        optionsList.add("");
        result.add(optionsList);
        for (Course course : option.courses) {
          List<String> courseList = new ArrayList<>();
          courseList.add(course.code);
          courseList.add(course.name);
          result.add(courseList);
        }
      }
    }
    return result;
  }
}
